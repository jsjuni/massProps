---
title: "massProps"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{massProps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rollupTree)
library(massProps)
```

# Overview

The `massProps` package extends `rollupTree` with functions to recursively calculate mass properties (and optionally, their uncertainties). Formulas implemented are described in a technical paper published by the Society of Allied Weight Engineers.[@zimmerman:05:sawe]

# Synopsis

## Data Structures

`massProps` operates on two fundamental data structures: a mass properties table and a tree. The mass properties table has an entry for every item in a tree structure of items; the edges of the tree convey the parent-child relations among items. The two data structures are linked by the `id` column of the data frame, which must be a character vector of unique item identifiers, and the vertex names of the tree. The sets of identifiers must be identical.

### Mass Property Table

#### Required Columns for Mass Properties

The Mass Property Table must contain the following columns. Other columns may exist and will remain unmodified.

-   `id` unique identifier for each item (row)

-   `mass` mass of the item (numeric)

-   `Cx` $x$-component of center of mass (numeric)

-   `Cy` $y$-component of center of mass (numeric)

-   `Cx` $z$-component of center of mass (numeric)

-   `Ixx` moment of inertia about the $x$ axis (numeric)

-   `Iyy` moment of inertia about the $y$ axis (numeric)

-   `Izz` moment of inertia about the $z$ axis (numeric)

-   `Ixy` product of inertia relative to the $x$ and $y$ axes (numeric)

-   `Ixz` product of inertia relative to the $x$ and $z$ axes (numeric)

-   `Iyz` product of inertia relative to the $y$ and $z$ axes (numeric)

-   `POIconv` either '+' or '-', indicating the sign convention for products of inertia[^1]

-   `Ipoint` logical indicator that this item is considered a point mass (i.e., its inertia contribution is negligible)[^2]

[^1]: In the negative convention, for example, $I_{XY} \equiv -\int xy \rho \thinspace dV$. In the positive convention, $I_{XY} \equiv \int xy \rho \thinspace dV$.

[^2]: The same algebraic result can be achieved by setting all moments and products of inertia to zero, but `rollup_mass_props()` by default ensures that all leaf items in the tree have mass properties that correspond to physically-realizable objects. A zero inertia tensor will fail this check. Rather than relax the check (which is essential for trustworthy results), a `TRUE` value for `Ipoint` indicates that the inertia tensor should be excluded from computations. \`\`

#### Required Columns for Mass Properties Uncertainty

The following columns are required for uncertainty calculations:

-   `σ_mass` mass uncertainty (numeric)

-   `σ_Cx` $x$-component of center of mass uncertainty (numeric)

-   `σ_Cy` $y$-component of center of mass uncertainty (numeric)

-   `σ_Cx` $z$-component of center of mass uncertainty (numeric)

-   `σ_Ixx` moment of inertia about the $x$ axis uncertainty (numeric)

-   `σ_Iyy` moment of inertia about the $y$ axis uncertainty (numeric)

-   `σ_Izz` moment of inertia about the $z$ axis uncertainty (numeric)

-   `σ_Ixy` product of inertia relative to the $x$ and $y$ axes uncertainty (numeric)

-   `σ_Ixz` product of inertia relative to the $x$ and $z$ axes uncertainty (numeric)

-   `σ_Iyz` product of inertia relative to the $y$ and $z$ axes uncertainty (numeric)

It is the caller's responsibility to ensure that all values are expressed in appropriate and compatible units.

#### Tree

The tree is an `igraph::graph` with vertices named by identifiers in the mass properties table. The graph must satisfy certain well-formedness properties:

-   it is connected an acyclic (as an undirected graph), i.e., it is a tree

-   it is directed, with edge direction going from child to parent

-   it contains neither loops (self-edges) or multiple edges

-   it contains a single root vertex (i.e., one whose out degree is zero)

## Invocation

Suppose we have the following mass properties table:

```{r}
test_table
```

Suppose we also have this tree:

```{r}
suppressPackageStartupMessages({library(igraph)})
test_tree
```

Then we can compute mass properties for non-leaf elements by calling `rollup_mass_props()`:

```{r}
library(massProps)
rollup_mass_props(test_tree, test_table)
```

The input may also contain uncertainty data. This example is from the Society of Allied Weight Engineers:

```{r echo = FALSE}
na_mass_props_and_unc <- function(d, t, v) {
  xyz <- c("x", "y", "z")
  list(
    mass = NA,
    center_mass = c(x = NA, y = NA, z = NA),
    inertia = matrix(nrow = 3, ncol = 3, dimnames = list(xyz, xyz)),
    poi_conv = "+",
    point = FALSE,
    sigma_mass = NA,
    sigma_center_mass = c(x = NA, y = NA, z = NA),
    sigma_inertia = matrix(nrow = 3, ncol = 3, dimnames = list(xyz, xyz))
  )
}
na_mass_props_and_unc_update <- function(d, t, s) {
  update_mass_props_and_unc(d, t, s, override = na_mass_props_and_unc)
}
sawe_input <- rollup(sawe_tree, sawe_table, update = na_mass_props_and_unc_update, validate_ds = validate_mass_props_and_unc_table)
```

```{r}
sawe_input
```

```{r}
rollup_mass_props_and_unc(sawe_tree, sawe_input)
```

# Objectives and Strategy

The objective of this package is to provide a trustworthy, well-documented, reference implementation for computation of mass properties (and their uncertainties) of aggregate objects from those of their parts. Aggregation can be recursive (e.g., indentured Bill of Materials), so it must accommodate trees of arbitrary depth and shape.

Strategies for achieving the objective include

-   basing the calculations on published industry references,

-   re-casting those lengthy reference equations into concise vector or matrix forms to reduce the error surface for source code and exploit the capabilities of `R`, which treats vectors and matrices as first-class objects,

-   delegating the orchestration to the `rollupTree` package, which, among other things, verifies that the input tree is well-formed,

-   ensuring that all asserted leaf mass properties and uncertainties correspond to physically-realizable objects,

-   writing the code in pure functional style, and

-   covering the entire code base with unit tests.

The author has intentionally made no effort to optimize for performance. That said, in its current form it handles computations on the scale encountered in the design of interplanetary spacecraft in a few seconds.

# Theory

In this section, we state the reference equations [@zimmerman:05:sawe] and show, where applicable, how those equations can be rewritten in more concise form. The form of the equations actually implemented is displayed within a box, e.g. $\boxed{F = ma}$.

The reference uses the word *weight* and the symbol $w$ in equations. We interpret weight as mass. The reference refers to center of mass by its $x$, $y$, and $z$ components. Symbols for moments ($I_{XX}$) and products ($I_{XY}$) of inertia are conventional. Variables with subscripts designate properties of parts; those without designate properties of aggregates. The letter $\sigma$ denotes uncertainty. $\sigma_w$, for example, is the mass uncertainty

### Mass

The mass equation is suitable as is.

$$
\boxed{
\newcommand{\sumwi}{\sum_{i=1}^{n}w_i}
w = \sumwi
}
$$

The corresponding `R` code is

``` r
r$mass <- Reduce(`+`, Map(f = function(v) v$mass, vl))
```

### Center of Mass

$$
\newcommand{\sumwivi}[1]{\sum_{i=1}^{n}{w_i}{{#1}_i}}
\begin{align}
\bar{x} & = \sumwivi{x} \bigg/ \sumwi \\
\bar{y} & = \sumwivi{y} \bigg/ \sumwi \\
\bar{z} & = \sumwivi{z} \bigg/ \sumwi \\
\end{align}
$$

We can express center of mass as a 3-vector:

$$
\boxed{
\begin{align}
\boldsymbol{c}_i & = (x_i \quad y_i \quad z_i)^T \\
\boldsymbol{\bar{c}}& = (\bar{x} \quad \bar{y} \quad \bar{z})^T
\end{align}
}
$$

Then

$$
\boxed{
\boldsymbol{\bar{c}} = \frac{1}{w} \sumwivi{\boldsymbol{c}}
}
$$

The corresponding `R` code is

``` r
r$center_mass <- Reduce(`+`, Map(f = function(v) v$mass * v$center_mass, vl)) / r$mass
```

### Inertia Tensor

#### Moments of Inertia

$$
\newcommand{\moia}[3]{
\sum_{i=1}^{n} \left[ {I_{#1}}_i
  + w_i \left( {#2}_i^2 + {#3}_i^2 \right)
  - w_i \left( \bar{#2}^2 + \bar{#3}^2 \right)
\right]
}
\newcommand{\moib}[3]{
\sum_{i=1}^{n} \left\{ {I_{#1}}_i
  + w_i \left[ \left( {#2}_i - \bar{#2} \right)^2 + \left( {#3}_i - \bar{#3} \right)^2 \right]
\right\}
}
\begin{align}
I_{XX} & = \moia{XX}{y}{z} & = \moib{XX}{y}{z} \\
I_{YY} & = \moia{YY}{x}{z} & = \moib{YY}{x}{z} \\
I_{ZZ} & = \moia{ZZ}{x}{y} & = \moib{ZZ}{x}{y} \\
\end{align}
$$

#### Products of Inertia

$$
\newcommand{\di}[1]{({#1}_i - \bar{#1})}
\newcommand{\poia}[3]{\sum_{i=1}^{n} \left[ {I_{#1}}_i + w_i {{#2}_i}{{#3}_i} -w_i (\bar{#2}\bar{#3})\right]}
\newcommand{\poib}[3]{\sum_{i=1}^{n} \left[ {I_{#1}}_i + w_i \di{#2}\di{#3}\right]}
\begin{align}
I_{XY} & = \poia{XY}{x}{y} & = \poib{XY}{x}{y} \\
I_{XZ} & = \poia{XZ}{x}{z} & = \poib{XZ}{x}{z} \\
I_{YZ} & = \poia{YZ}{y}{z} & = \poib{YZ}{y}{z} \\
\end{align}
$$

#### Matrix Formulation

Let $I$ be the inertia tensor of the aggregate and $I_i$ be that of part $i$. The equations for products of inertia above clearly follow the positive integral convention, so

$$
I =
\left[ \begin{matrix}
 I_{XX} & -I_{XY} & -I_{XZ} \\
-I_{XY} &  I_{YY} & -I_{YZ} \\
-I_{XZ} & -I_{YZ} &  I_{ZZ} 
\end{matrix}
\right]
$$

and similarly for $I_i$.

Noting the repeated appearance of terms of the form $\di{x}$, we form the outer product

$$
\boxed{
\begin{align}
\boldsymbol{d}_i & = (\di{x} \quad \di{y} \quad \di{z})^T \\
\boldsymbol{Q}_i & = \boldsymbol{d}_i {\boldsymbol{d}_i}^T
\end{align}
}
$$ Then

$$
\begin{align}
\boldsymbol{Q}_i & =
\begin{bmatrix}
\di{x}^2     & \di{x}\di{y} & \di{x}\di{z} \\
\di{y}\di{x} & \di{y}^2     & \di{y}\di{z} \\
\di{z}\di{x} & \di{z}\di{y} & \di{z}^2     \\
\end{bmatrix}
\end{align}
$$

Let $\boldsymbol{s}_i$ be the matrix of inertia tensor summands from the reference equations. That is,

$$
\boldsymbol{I} = \sum_{i=1}^{n} \boldsymbol{s}_i
$$

where $$
\begin{align}
\boldsymbol{s}_i & = \boldsymbol{I}_i \\
& -
w_i \begin{bmatrix}
-\di{y}^2 - \di{z}^2 & \di{x}\di{y}         & \di{x}\di{z}         \\
\di{x}\di{y}         & -\di{x}^2 - \di{z}^2 &  \di{y}\di{z}        \\
\di{x}\di{z}         & \di{y}\di{z}         & -\di{x}^2 - \di{y}^2 \\
\end{bmatrix} \\
& =
\boldsymbol{I}_i \\
& -
w_i \begin{bmatrix}
\di{x}^2     & \di{x}\di{y} & \di{x}\di{z} \\
\di{x}\di{y} & \di{y}^2     & \di{y}\di{z} \\
\di{x}\di{z} & \di{y}\di{z} & \di{z}^2     \\
\end{bmatrix} \\
& -
w_i \begin{bmatrix}
-\di{x}^2 - \di{y}^2 - \di{z}^2 & 0                               & 0                              \\
0                               & -\di{x}^2 - \di{y}^2 - \di{z}^2 & 0                              \\
0                               & 0                               &-\di{x}^2 - \di{y}^2 - \di{z}^2 \\
\end{bmatrix} \\
& = 
\boldsymbol{I}_i
- 
w_i \left( \boldsymbol{Q}_i - \mathrm{tr}(\boldsymbol{Q}_i) \boldsymbol{I}_3 \right)
\end{align}
$$

Therefore

$$
\boxed{
\boldsymbol{I} = \sum_{i=1}^{n} \left\{ \boldsymbol{I}_i
- 
w_i \left( \boldsymbol{Q}_i - \mathrm{tr}(\boldsymbol{Q}_i) \boldsymbol{I}_3 \right) \right\}
}
$$

The corresponding `R` code is

``` {.R .R}
r$inertia <- Reduce(`+`, Map(
  f  = function(v) {
    d <- r$center_mass - v$center_mass
    d_ss2 <- outer(d, d) - sum(d^2) * diag(3)
    if (v$point) -v$mass * d_ss2 else v$inertia - v$mass * d_ss2
  },
  vl
))
```

## Mass Property Uncertainties

### Mass Uncertainty

The mass uncertainty equation is suitable as is.

$$
\boxed{
\sigma_w = \sqrt{ \sum_{i=1}^n {{\sigma_w}_i}^2 }
}
$$

The corresponding `R` code is

``` R
r$sigma_mass = sqrt(Reduce(`+`, Map(f = function(v) v$sigma_mass^2, vl)))
```

### Center of Mass Uncertainty

$$
\newcommand{\sumwi}{\sum_{i=1}^n w_i}
\newcommand{\sigmacm}[2]{
\sqrt{ \sum_{i=1}^n \big\{ (w_i {{#1}}_i)^2 + [{\sigma_w}_i \di{#2}]^2 \big\}}
}
\begin{align}
\sigma_x & = \sigmacm{\sigma_x}{x} \bigg/ \sumwi \\
\sigma_y & = \sigmacm{\sigma_y}{y} \bigg/ \sumwi \\
\sigma_z & = \sigmacm{\sigma_z}{z} \bigg/ \sumwi \\
\end{align}
$$

As before, we create a 3-vector for center of mass uncertainties. Let

$$
\boxed{
\begin{align}
\boldsymbol{\sigma_c} & = (\sigma_x \quad \sigma_y \quad \sigma_z)^T \\
{\boldsymbol{\sigma_c}}_i & = ({\sigma_x}_i \quad {\sigma_y}_i \quad {\sigma_z}_i)^T
\end{align}
}
$$

If we construe (as `R` does) squaring and taking square roots of vectors element-wise, then

$$
\boxed{
\boldsymbol{\sigma_c} = \frac{1}{w} \sigmacm{\boldsymbol{\sigma_c}}{\boldsymbol{c}}
}
$$

The corresponding `R` code is

``` R
r$sigma_center_mass = sqrt(Reduce(`+`, Map(
  f = function(v) {
    (v$mass * v$sigma_center_mass) ^ 2 +
      (v$sigma_mass * (v$center_mass - r$center_mass)) ^ 2
  },
  vl
))) / r$mass
```

### Inertia Tensor Uncertainty

#### Moments of Inertia Uncertainties

$$
\newcommand{\sigmamoi}[3]{\sqrt{ \sum_{i=1}^n \big\{  \sigma_{{I_{#1}}_i}^2 + \big[ 2 w_i \di{#2} \sigma_{{#2}_i} \big]^2 + \big[ 2 w_i \di{#3} \sigma_{{#3}_i} \big]^2 + \big[ \big(\di{#2}^2 + \di{#3}^2 \big)\sigma_{w_i}\big]^2 \big\} }}
\begin{align}
\sigma_{I_{XX}} & = \sigmamoi{XX}{y}{z} \\
\sigma_{I_{YY}} & = \sigmamoi{YY}{x}{z} \\
\sigma_{I_{ZZ}} & = \sigmamoi{ZZ}{x}{y} \\
\end{align}
$$

#### Products of Inertia Uncertainties

$$
\newcommand{\sigmapoi}[3]{\sqrt{ \sum_{i=1}^n \big\{  \sigma_{{I_{#1}}_i}^2 + \big[ \di{#2} w_i \sigma_{{#3}_i}\big]^2 + \big[  \di{#2}\di{#3}\sigma_{w_i} \big]^2 + \big[ \di{#3}  w_i \sigma_{{#2}_i} \big]^2 \big\} }}
\begin{align}
\sigma_{I_{XY}} & = \sigmapoi{XY}{x}{y} \\
\sigma_{I_{XZ}} & = \sigmapoi{XZ}{x}{z} \\
\sigma_{I_{YZ}} & = \sigmapoi{YZ}{y}{z} \\
\end{align}
$$

#### Matrix Formulation

Let

$$
\boxed{
\begin{align}
\boldsymbol{d}_i & = (\di{x} \quad \di{y} \quad \di{z})^T \\
{\boldsymbol{\sigma_c}}_i & = ({\sigma_x}_i \quad {\sigma_y}_i \quad {\sigma_z}_i)^T \\
\boldsymbol{P}_i & = \boldsymbol{d}_i {\boldsymbol{\sigma_c}}_i^T \\
\boldsymbol{Q}_i & = \boldsymbol{d}_i {\boldsymbol{d}_i}^T
\end{align}
}
$$

Then

$$
\begin{align}
\boldsymbol{P}_i & = 
\begin{bmatrix}
(x_i - \bar{x})\sigma_{x_i} &\di{x}\sigma_{y_i} &\di{x}\sigma_{z_i} \\
\di{y}\sigma_{x_i} & \di{y}\sigma_{y_i} & \di{y}\sigma_{z_i} \\
\di{z}\sigma_{x_i} & \di{z}\sigma_{y_i} & \di{z}\sigma_{z_i} \\
\end{bmatrix}
\\
\\
\boldsymbol{Q}_i & =
\begin{bmatrix}
(x_i - \bar{x})^2 &\di{x}\di{y} &\di{x}\di{z} \\
\di{y}(x_i - \bar{x}) & \di{y}^2 & \di{y}\di{z} \\
\di{z}(x_i - \bar{x}) & \di{z}\di{y} & \di{z}^2 \\
\end{bmatrix}
\end{align}
$$

Let $\boldsymbol{s}_i^2$ be the matrix of inertia tensor uncertainty summands in the standard formulas for a given subcomponent $i$ above. That is,

$$
\boldsymbol{\sigma_I}^2 = \sum_{i=1}^{} \boldsymbol{s}_i^2
$$

Let ${p_X}_i$, ${p_Y}_i$, and ${p_Z}_i$ be the respective diagonal elements of $P_i$. If we interpret squaring a matrix as the Hadamard (element-wise) product with itself, then $$
\begin{align}
\boldsymbol{s}_i^2 & = {\boldsymbol{\sigma_I}}_i^2 \\
& + 
\begin{bmatrix}
2 w_i \di{y} \sigma_{y_i} &   w_i\di{x} \sigma_{y_i} &   w_i\di{x} \sigma_{z_i} \\
  w_i\di{x} \sigma_{y_i} & 2 w_i\di{x} \sigma_{x_i} &   w_i \di{y} \sigma_{z_i} \\
  w_i\di{x} \sigma_{z_i} &   w_i \di{y} \sigma_{z_i} & 2 w_i\di{x} \sigma_{x_i}
\end{bmatrix}^2 \\
& +
\begin{bmatrix}
2 w_i \di{z} \sigma_{z_i} &   w_i \di{y} \sigma_{x_i} &   w_i \di{z} \sigma_{x_i} \\
  w_i \di{y} \sigma_{x_i} & 2 w_i \di{z} \sigma_{z_i} &   w_i \di{z} \sigma_{y_i} \\
  w_i \di{z} \sigma_{x_i} &   w_i \di{z} \sigma_{y_i} & 2 w_i \di{y} \sigma_{y_i}
\end{bmatrix}^2 \\
& +
\begin{bmatrix}
(\di{y}^2 + \di{z}^2)\sigma_{w_i} &\di{x}\di{y}\sigma_{w_i} &\di{x}\di{z}\sigma_{w_i} \\
\di{y}(x_i - \bar{x})\sigma_{w_i} & ((x_i - \bar{x})^2 + \di{z}^2)\sigma_{w_i} & \di{y}\di{z}\sigma_{w_i} \\
\di{z}(x_i - \bar{x})\sigma_{w_i} & \di{z}\di{y}\sigma_{w_i} & ((x_i - \bar{x})^2 + \di{y}^2)\sigma_{w_i} \\
\end{bmatrix}^2 \\ \\
& = {\boldsymbol{\sigma_I}}_i^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i -
\begin{bmatrix}
(x_i - \bar{x})\sigma_{x_i} - 2 \di{y}\sigma_{y_i} & 0 & 0 \\
0 & \di{y}\sigma_{y_i} - 2\di{x}\sigma_{x_i} & 0 \\
0 & 0 & \di{z}\sigma_{y_i} - 2\di{x}\sigma_{x_i} \\
\end{bmatrix}
\right) ^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i^T -
\begin{bmatrix}
(x_i - \bar{x})\sigma_{x_i} - 2 \di{z}\sigma_{y_i} & 0 & 0 \\
0 & \di{y}\sigma_{y_i} - 2 \di{z}\sigma_{z_i} & 0 \\
0 & 0 & \di{z}\sigma_{y_i} - 2 \di{y}\sigma_{y_i} \\
\end{bmatrix}
\right) ^2 \\
& + \sigma_{w_i}^2 \left(
\boldsymbol{Q}_i - \mathrm{tr}(\boldsymbol{Q}_i)\boldsymbol{I}_3
\right)^2 \\ \\
& = {\boldsymbol{\sigma_I}}_i^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i -
\begin{bmatrix}
 {p_X}_i - 2 {p_Y}_i & 0 & 0 \\
0 & {p_Y}_i - 2 {p_X}_i & 0 \\
0 & 0 & {p_Z}_i - 2  {p_X}_i \\
\end{bmatrix}
\right) ^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i^T -
\begin{bmatrix}
 {p_X}_i - 2{p_Z}_i & 0 & 0 \\
0 & {p_Y}_i - 2 {p_Z}_i & 0 \\
0 & 0 & {p_Z}_i - 2 {p_Y}_i \\
\end{bmatrix}
\right) ^2 \\
& + \sigma_{w_i}^2 \left(
\boldsymbol{Q}_i - \mathrm{tr}(\boldsymbol{Q}_i)\boldsymbol{I}_3
\right)^2
\end{align}
$$

Finally,

$$
\boxed{
\boldsymbol{\sigma_I} = \left(
\sum_{i=1}^{n} {\left\{
\begin{align}
{\boldsymbol{\sigma_I}}_i^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i -
\begin{bmatrix}
{p_X}_i + 2 {p_Y}_i & 0 & 0 \\
0 & {p_Y}_i + 2 {p_X}_i & 0 \\
0 & 0 & {p_Z}_i + 2  {p_X}_i \\
\end{bmatrix}
\right) ^2 \\
& + w_i^2 \left(
\boldsymbol{P}_i^T -
\begin{bmatrix}
 {p_X}_i + 2{p_Z}_i & 0 & 0 \\
0 & {p_Y}_i + 2 {p_Z}_i & 0 \\
0 & 0 & {p_Z}_i + 2 {p_Y}_i \\
\end{bmatrix}
\right) ^2 \\
& + \sigma_{w_i}^2 \left(
\boldsymbol{Q}_i - \mathrm{tr}(\boldsymbol{Q}_i)\boldsymbol{I}_3
\right)^2
\end{align}
\right\}}
\right)^\frac{1}{2}
}
$$

The corresponding `R` code is

``` R
r$sigma_inertia = sqrt(Reduce(`+`, Map(
  f = function(v) {

    d <- r$center_mass - v$center_mass

    P <- outer(d, v$sigma_center_mass)
    p <- diag(P)
    diag_1 <- diag(c(p['x'] + 2 * p['y'], p['y'] + 2 * p['x'], p['z'] + 2 * p['x']))
    diag_2 <- diag(c(p['x'] + 2 * p['z'], p['y'] + 2 * p['z'], p['z'] + 2 * p['y']))

    Q <- outer(d, d)
    diag_3 <- sum(diag(Q)) * diag(3)

    v$sigma_inertia^2 + (v$mass * (P - diag_1))^2 + (v$mass * (t(P) - diag_2))^2 +
      (v$sigma_mass * (Q - diag_3))^2
  },
  vl
)))
```

# Testing and Validation

# References
